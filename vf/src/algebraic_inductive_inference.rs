use std::collections::hash_map::Entry;
use std::collections::HashMap;
use std::hash::Hash;
use num_traits::AsPrimitive;


// /**S is the set of states (S is a group). We are using HashMap as a form of "associative memory" so S must be hashable.
//  We assume that set A of agent actions is encoded as char symbols. The result of this function is the set of words
// which encode relators R. Thus the result is presentation <A,R> of group S. There is a morphism A->char.*/
// pub fn infer<S:Hash+Eq+Copy>(trajectory:&[(S,char)], actions:char)->Vec<String>{
//
// }
// /**S is the set of elements of some group generated by A.
// The generator set is encoded as char symbols (there is a morphism A->char).
// Input is a trajectory sampled using a (random) walk over Cayley graph of S.
// The result are labels of all cycles found in the trajectory. Label is defined as word
// resulting from concatenation of A from consecutive edges of some path (https://en.wikipedia.org/wiki/Path_(graph_theory)).*/
// pub fn find_labels_of_cycles<S:Hash+Eq+Copy>(trajectory:&[(S,char)])->Vec<String>{
//     let mut last_state_visit = HashMap::<S,usize>::new();
//     let mut presentation = Vec::<String>::new();
//     for (idx,(state,_)) in trajectory.iter().cloned().enumerate(){
//         match last_state_visit.entry(state){
//             Entry::Occupied(mut last_visit_idx) => {
//                 let prev_idx = *last_visit_idx.get();
//                 let sub_trajectory = &trajectory[prev_idx..idx];
//                 let word = sub_trajectory.iter().map(|(s,a)|*a).collect::<String>();
//                 // notice that the last action trajectory[idx].1 is not included in the word
//                 presentation.push(word);
//                 last_visit_idx.insert(idx);
//             },
//             Entry::Vacant(first_visit) => first_visit.insert(idx)
//         }
//     }
//     presentation
// }
// /**Removes duplicate relators, including when that appear as subwords (substrings).*/
// pub fn deduplicate_presentation(presentation:&mut Vec<String>){
//     presentation.sort_by_key(String::len);
//     let mut i = 0;
//     while i < presentation.len(){
//         for j in {
//
//         }
//         i+=1;
//     }
//
// }
// pub fn prune_relator_basis<S:Hash+Eq+Copy>(trajectory:&[(S,char)], actions:char)->Vec<String>{
//
// }